以下是涵盖以下内容的各类重要规则：
- 开发流程（dev_workflow）
- `.windsurfrules` 文档自改进流程
- 修改或添加本文件新章节/规则时需遵循的模板

---
开发流程（DEV_WORKFLOW）
---
说明：使用元开发脚本（scripts/dev.js）管理基于任务的开发工作流程的指南
适用模式：**/*
适用文件：**/*
始终应用：是
---

- **全局 CLI 命令**
  - Task Master 现通过 `task-master` 命令提供全局 CLI
  - `scripts/dev.js` 的所有功能都可通过此界面使用
  - 使用 `npm install -g claude-task-master` 全局安装，或通过 `npx` 本地使用
  - 使用 `task-master <command>` 替代 `node scripts/dev.js <command>`
  - 示例：
    - 使用 `task-master list` 替代 `node scripts/dev.js list`
    - 使用 `task-master next` 替代 `node scripts/dev.js next`
    - 使用 `task-master expand --id=3` 替代 `node scripts/dev.js expand --id=3`
  - 所有命令与脚本等效选项相同
  - CLI 还提供额外命令，如 `task-master init` 用于项目设置

- **开发工作流程**
  - 通过运行 `task-master init` 或 `node scripts/dev.js parse-prd --input=<prd-file.txt>` 生成初始 tasks.json 来启动新项目
  - 使用 `task-master list` 查看当前任务、状态和 ID，开始编码会话
  - 在分解任务前，使用 `task-master analyze-complexity --research` 分析任务复杂度
  - 根据依赖项（均标记为“已完成”）、优先级和 ID 顺序选择任务
  - 通过检查 tasks/ 目录中的任务文件或询问用户输入来澄清任务
  - 使用 `task-master show <id>` 查看特定任务详情，了解实现要求
  - 使用 `task-master expand --id=<id>` 及适当标志分解复杂任务
  - 如需重新生成子任务，先使用 `task-master clear-subtasks --id=<id>` 清除现有子任务
  - 按照任务详情、依赖项和项目标准实现代码
  - 按照测试策略验证任务后，标记为完成
  - 使用 `task-master set-status --id=<id> --status=done` 标记已完成任务
  - 当实现与原计划不同时，更新依赖任务
  - 更新 tasks.json 后，使用 `task-master generate` 生成任务文件
  - 如有需要，使用 `task-master fix-dependencies` 维护有效的依赖结构
  - 尊重依赖链和任务优先级，选择工作时
  - 使用 list 命令定期报告进度

- **任务复杂度分析**
  - 运行 `node scripts/dev.js analyze-complexity --research` 进行全面分析
  - 在 scripts/task-complexity-report.json 中查看复杂度报告
  - 或使用 `node scripts/dev.js complexity-report` 查看格式化、可读的报告版本
  - 关注复杂度得分最高（8-10）的任务，进行详细分解
  - 根据分析结果确定适当的子任务分配
  - 注意报告会自动被 expand 命令使用

- **任务分解流程**
  - 对于已完成复杂度分析的任务，使用 `node scripts/dev.js expand --id=<id>`
  - 否则使用 `node scripts/dev.js expand --id=<id> --subtasks=<number>`
  - 添加 `--research` 标志，利用 Perplexity AI 进行有研究支持的扩展
  - 如有需要，使用 `--prompt="<context>"` 提供额外上下文
  - 根据需要审查和调整生成的子任务
  - 使用 `--all` 标志一次性扩展所有待处理任务
  - 如果需要重新生成子任务，先使用 `clear-subtasks` 命令清除

- **实现偏差处理**
  - 当实现与计划方法有显著差异时
  - 当当前实现选择需要修改后续任务时
  - 当出现新的依赖项或需求时
  - 使用 `node scripts/dev.js update --from=<futureTaskId> --prompt="<explanation>"` 更新 tasks.json

- **任务状态管理**
  - 使用“待处理”表示已准备好开始的任务
  - 使用“已完成”表示已验证完成的任务
  - 使用“推迟”表示推迟的任务
  - 根据项目特定工作流程需要，添加自定义状态值

- **任务文件格式参考**
  ```
  # 任务 ID：<id>
  # 标题：<title>
  # 状态：<status>
  # 依赖项：<以逗号分隔的依赖项 ID 列表>
  # 优先级：<priority>
  # 描述：<简要描述>
  # 详细信息：
  <详细实现说明>
  
  # 测试策略：
  <验证方法>
  ```

- **命令参考：parse-prd**
  - 旧语法：`node scripts/dev.js parse-prd --input=<prd-file.txt>`
  - CLI 语法：`task-master parse-prd --input=<prd-file.txt>`
  - 说明：解析 PRD 文档并生成结构化的 tasks.json 文件
  - 参数：
    - `--input=<file>`：PRD 文本文件路径（默认：sample-prd.txt）
  - 示例：`task-master parse-prd --input=requirements.txt`
  - 注意：会覆盖现有 tasks.json 文件。使用时需谨慎。

- **命令参考：update**
  - 旧语法：`node scripts/dev.js update --from=<id> --prompt="<prompt>"`
  - CLI 语法：`task-master update --from=<id> --prompt="<prompt>"`
  - 说明：根据提供的提示更新 ID 大于或等于指定 ID 的任务
  - 参数：
    - `--from=<id>`：开始更新的起始任务 ID（必需）
    - `--prompt="<text>"`：变更说明或新上下文（必需）
  - 示例：`task-master update --from=4 --prompt="Now we are using Express instead of Fastify."`
  - 注意：仅更新未标记为“已完成”的任务。已完成的任务保持不变。

- **命令参考：generate**
  - 旧语法：`node scripts/dev.js generate`
  - CLI 语法：`task-master generate`
  - 说明：根据 tasks.json 在 tasks/ 目录中生成单独的任务文件
  - 参数：
    - `--file=<path>, -f`：使用替代的 tasks.json 文件（默认：'tasks/tasks.json'）
    - `--output=<dir>, -o`：输出目录（默认：'tasks'）
  - 示例：`task-master generate`
  - 注意：会覆盖现有任务文件。如需要，会创建 tasks/ 目录。

- **命令参考：set-status**
  - 旧语法：`node scripts/dev.js set-status --id=<id> --status=<status>`
  - CLI 语法：`task-master set-status --id=<id> --status=<status>`
  - 说明：更新 tasks.json 中特定任务的状态
  - 参数：
    - `--id=<id>`：要更新的任务 ID（必需）
    - `--status=<status>`：新的状态值（必需）
  - 示例：`task-master set-status --id=3 --status=done`
  - 注意：常见值为“已完成”、“待处理”和“推迟”，但接受任何字符串。

- **命令参考：list**
  - 旧语法：`node scripts/dev.js list`
  - CLI 语法：`task-master list`
  - 说明：列出 tasks.json 中的所有任务，包括 ID、标题和状态
  - 参数：
    - `--status=<status>, -s`：按状态筛选
    - `--with-subtasks`：显示每个任务的子任务
    - `--file=<path>, -f`：使用替代的 tasks.json 文件（默认：'tasks/tasks.json'）
  - 示例：`task-master list`
  - 注意：提供项目进度的快速概览。会话开始时使用。

- **命令参考：expand**
  - 旧语法：`node scripts/dev.js expand --id=<id> [--num=<number>] [--research] [--prompt="<context>"]`
  - CLI 语法：`task-master expand --id=<id> [--num=<number>] [--research] [--prompt="<context>"]`
  - 说明：为详细实现扩展任务的子任务
  - 参数：
    - `--id=<id>`：要扩展的任务 ID（除非使用 --all，否则为必需）
    - `--all`：按复杂度优先级扩展所有待处理任务
    - `--num=<number>`：要生成的子任务数量（默认：来自复杂度报告）
    - `--research`：使用 Perplexity AI 进行有研究支持的生成
    - `--prompt="<text>"`：子任务生成的额外上下文
    - `--force`：即使任务已有子任务，也重新生成子任务
  - 示例：`task-master expand --id=3 --num=5 --research --prompt="Focus on security aspects"`
  - 注意：如有可用，使用复杂度报告的建议。

- **命令参考：analyze-complexity**
  - 旧语法：`node scripts/dev.js analyze-complexity [options]`
  - CLI 语法：`task-master analyze-complexity [options]`
  - 说明：分析任务复杂度并生成扩展建议
  - 参数：
    - `--output=<file>, -o`：输出文件路径（默认：scripts/task-complexity-report.json）
    - `--model=<model>, -m`：覆盖使用的 LLM 模型
    - `--threshold=<number>, -t`：扩展建议的最低分数（默认：5）
    - `--file=<path>, -f`：使用替代的 tasks.json 文件
    - `--research, -r`：使用 Perplexity AI 进行有研究支持的分析
  - 示例：`task-master analyze-complexity --research`
  - 注意：报告包括复杂度分数、推荐的子任务和定制的提示。

- **命令参考：clear-subtasks**
  - 旧语法：`node scripts/dev.js clear-subtasks --id=<id>`
  - CLI 语法：`task-master clear-subtasks --id=<id>`
  - 说明：从指定任务中移除子任务，以便重新生成
  - 参数：
    - `--id=<id>`：要清除子任务的任务 ID 或以逗号分隔的 ID 列表
    - `--all`：清除所有任务的子任务
  - 示例：
    - `task-master clear-subtasks --id=3`
    - `task-master clear-subtasks --id=1,2,3`
    - `task-master clear-subtasks --all`
  - 注意：
    - 清除子任务后，任务文件会自动重新生成
    - 可与 expand 命令结合，立即生成新的子任务
    - 适用于父任务和单个子任务

- **任务结构字段**
  - **id**：任务的唯一标识符（示例：`1`）
  - **title**：简短、描述性的标题（示例：`"Initialize Repo"`）
  - **description**：对任务涉及内容的简洁总结（示例：`"Create a new repository, set up initial structure."`）
  - **status**：任务的当前状态（示例：`"pending"`、`"done"`、`"deferred"`）
  - **dependencies**：先决任务的 ID 列表（示例：`[1, 2]`）
    - 依赖项会显示状态指示器（已完成为✅，待处理为⏱️）
    - 这有助于快速识别哪些先决任务阻碍了工作
  - **priority**：重要性级别（示例：`"high"`、`"medium"`、`"low"`）
  - **details**：深入的实现说明（示例：`"Use GitHub client ID/secret, handle callback, set session token."`）
  - **testStrategy**：验证方法（示例：`"Deploy and call endpoint to confirm 'Hello World' response."`）
  - **subtasks**：更小、更具体任务的列表（示例：`[{"id": 1, "title": "Configure OAuth", ...}]`）

- **环境变量配置**
  - **ANTHROPIC_API_KEY**（必需）：您的 Anthropic API 密钥，用于 Claude（示例：`ANTHROPIC_API_KEY=sk-ant-api03-...`）
  - **MODEL**（默认：`"claude-3-7-sonnet-20250219"`）：使用的 Claude 模型（示例：`MODEL=claude-3-opus-20240229`）
  - **MAX_TOKENS**（默认：`"4000"`）：响应的最大令牌数（示例：`MAX_TOKENS=8000`）
  - **TEMPERATURE**（默认：`"0.7"`）：模型响应的温度（示例：`TEMPERATURE=0.5`）
  - **DEBUG**（默认：`"false"`）：启用调试日志（示例：`DEBUG=true`）
  - **TASKMASTER_LOG_LEVEL**（默认：`"info"`）：控制台输出级别（示例：`TASKMASTER_LOG_LEVEL=debug`）
  - **DEFAULT_SUBTASKS**（默认：`"3"`）：默认子任务数量（示例：`DEFAULT_SUBTASKS=5`）
  - **DEFAULT_PRIORITY**（默认：`"medium"`）：默认优先级（示例：`DEFAULT_PRIORITY=high`）
  - **PROJECT_NAME**（默认：`"MCP SaaS MVP"`）：元数据中的项目名称（示例：`PROJECT_NAME=My Awesome Project`）
  - **PROJECT_VERSION**（默认：`"1.0.0"`）：元数据中的版本（示例：`PROJECT_VERSION=2.1.0`）
  - **PERPLEXITY_API_KEY**：用于研究支持功能（示例：`PERPLEXITY_API_KEY=pplx-...`）
  - **PERPLEXITY_MODEL**（默认：`"sonar-medium-online"`）：Perplexity 模型（示例：`PERPLEXITY_MODEL=sonar-large-online`）

- **确定下一个任务**
  - 运行 `task-master next` 显示要处理的下一个任务
  - next 命令会识别所有依赖项均已满足的任务
  - 任务按优先级、依赖项数量和 ID 排序
  - 命令显示全面的任务信息，包括：
    - 基本任务详情和描述
    - 实现细节
    - 子任务（如果存在）
    - 上下文建议的操作
  - 开始任何新的开发工作前推荐使用
  - 尊重项目依赖结构
  - 确保按适当顺序完成任务
  - 提供常用任务操作的即用命令

- **查看特定任务详情**
  - 运行 `task-master show <id>` 或 `task-master show --id=<id>` 查看特定任务
  - 使用点表示法表示子任务：`task-master show 1.2`（显示任务 1 的第 2 个子任务）
  - 显示与 next 命令类似的信息，但针对特定任务
  - 对于父任务，显示所有子任务及其当前状态
  - 对于子任务，显示父任务信息和关系
  - 提供针对特定任务的上下文建议操作
  - 用于在实现前检查任务详情或查看状态

- **管理任务依赖项**
  - 使用 `task-master add-dependency --id=<id> --depends-on=<id>` 添加依赖关系
  - 使用 `task-master remove-dependency --id=<id> --depends-on=<id>` 移除依赖关系
  - 系统防止循环依赖和重复的依赖项条目
  - 在添加或移除依赖项前会检查依赖项是否存在
  - 依赖项变更后，任务文件会自动重新生成
  - 在任务列表和文件中，依赖项会以状态指示器显示

- **命令参考：add-dependency**
  - 旧语法：`node scripts/dev.js add-dependency --id=<id> --depends-on=<id>`
  - CLI 语法：`task-master add-dependency --id=<id> --depends-on=<id>`
  - 说明：在两个任务之间添加依赖关系
  - 参数：
    - `--id=<id>`：将依赖于另一个任务的任务 ID（必需）
    - `--depends-on=<id>`：将成为依赖项的任务 ID（必需）
  - 示例：`task-master add-dependency --id=22 --depends-on=21`
  - 注意：防止循环依赖和重复；自动更新任务文件

- **命令参考：remove-dependency**
  - 旧语法：`node scripts/dev.js remove-dependency --id=<id> --depends-on=<id>`
  - CLI 语法：`task-master remove-dependency --id=<id> --depends-on=<id>`
  - 说明：移除两个任务之间的依赖关系
  - 参数：
    - `--id=<id>`：要移除依赖项的任务 ID（必需）
    - `--depends-on=<id>`：要移除的依赖项任务 ID（必需）
  - 示例：`task-master remove-dependency --id=22 --depends-on=21`
  - 注意：检查依赖项是否存在；自动更新任务文件

- **命令参考：validate-dependencies**
  - 旧语法：`node scripts/dev.js validate-dependencies [options]`
  - CLI 语法：`task-master validate-dependencies [options]`
  - 说明：检查 tasks.json 和任务文件中的无效依赖项
  - 参数：
    - `--file=<path>, -f`：使用替代的 tasks.json 文件（默认：'tasks/tasks.json'）
  - 示例：`task-master validate-dependencies`
  - 注意：
    - 报告所有不存在的依赖项和自依赖项，但不修改文件
    - 提供任务依赖状态的详细统计
    - 使用 fix-dependencies 前，用于审核任务结构

- **命令参考：fix-dependencies**
  - 旧语法：`node scripts/dev.js fix-dependencies [options]`
  - CLI 语法：`task-master fix-dependencies [options]`
  - 说明：查找并修复 tasks.json 和任务文件中的所有无效依赖项
  - 参数：
    - `--file=<path>, -f`：使用替代的 tasks.json 文件（默认：'tasks/tasks.json'）
  - 示例：`task-master fix-dependencies`
  - 注意：
    - 移除对不存在任务和子任务的引用
    - 消除自依赖项（任务依赖于自身）
    - 用修正后的依赖项重新生成任务文件
    - 提供所有修复的详细报告

- **命令参考：complexity-report**
  - 旧语法：`node scripts/dev.js complexity-report [options]`
  - CLI 语法：`task-master complexity-report [options]`
  - 说明：以格式化、易于阅读的方式显示任务复杂度分析报告
  - 参数：
    - `--file=<path>, -f`：复杂度报告文件路径（默认：'scripts/task-complexity-report.json'）
  - 示例：`task-master complexity-report`
  - 注意：
    - 按复杂度分数显示任务，并提供推荐操作
    - 提供复杂度分布统计
    - 显示复杂任务的即用扩展命令
    - 如果没有报告，会提供交互式生成报告的选项

- **命令参考：add-task**
  - CLI 语法：`task-master add-task [options]`
  - 说明：使用 AI 向 tasks.json 添加新任务
  - 参数：
    - `--file=<path>, -f`：任务文件路径（默认：'tasks/tasks.json'）
    - `--prompt=<text>, -p`：要添加的任务描述（必需）
    - `--dependencies=<ids>, -d`：此任务依赖的任务 ID 列表，用逗号分隔
    - `--priority=<priority>`：任务优先级（高、中、低）（默认：'medium'）
  - 示例：`task-master add-task --prompt="Create user authentication using Auth0"`
  - 注意：使用 AI 将描述转换为具有适当细节的结构化任务

- **命令参考：init**
  - CLI 语法：`task-master init`
  - 说明：初始化具有 Task Master 结构的新项目
  - 参数：无
  - 示例：`task-master init`
  - 注意：
    - 创建初始项目结构及所需文件
    - 如果未提供，会提示项目设置
    - 如适当，会与现有文件合并
    - 可用于快速启动新的 Task Master 项目

- **代码分析与重构技巧**
  - **顶层函数搜索**
    - 使用 grep 模式匹配查找整个代码库中所有导出的函数
    - 命令：`grep -E "export (function|const) \w+|function \w+\(|const \w+ = \(|module\.exports" --include="*.js" -r ./`
    - 好处：
      - 不用阅读实现细节，就能快速识别所有公共 API 函数
      - 在重构期间（例如从单体结构迁移到模块化结构）比较不同文件中的函数
      - 验证重构模块中是否存在所有预期函数
      - 识别重复功能或命名冲突
    - 使用示例：
      - 从 `scripts/dev.js` 迁移到模块化结构时：`grep -E "function \w+\(" scripts/dev.js`
      - 检查目录中的函数导出：`grep -E "export (function|const)" scripts/modules/`
      - 查找潜在命名冲突：`grep -E "function (get|set|create|update)\w+\(" -r ./`
    - 变体：
      - 添加 `-n` 标志包含行号
      - 添加 `--include="*.ts"` 按文件扩展名过滤
      - 与 `| sort` 结合按字母顺序排列结果
    - 与重构工作流集成：
      - 首先映射源文件中的所有函数
      - 根据函数分组创建目标模块文件
      - 验证所有函数是否已正确迁移
      - 检查是否有无意的重复或遗漏

---
WINDSURF 规则（WINDSURF_RULES）
---
说明：创建和维护 WINDSURF 规则的指南，以确保一致性和有效性。
适用模式：.windsurfrules
适用文件：.windsurfrules
始终应用：是
---
以下是您在本文件中应如何结构化新规则章节的描述。
- **所需规则结构：**
  ```markdown
  ---
  description: 清晰的一行描述，说明该规则所强制执行的内容
  globs: path/to/files/*.ext, other/path/**/*
  alwaysApply: 布尔值
  ---

  - **主要点以粗体显示**
    - 带有详细信息的子点
    - 示例和解释
  ```

- **章节引用：**
  - 使用 `ALL_CAPS_SECTION` 引用文件
  - 示例：`WINDSURF_RULES`

- **代码示例：**
  - 使用特定语言的代码块
  ```typescript
  // ✅ DO：展示好的示例
  const goodExample = true;
  
  // ❌ DON'T：展示反面模式
  const badExample = false;
  ```

- **规则内容指南：**
  - 从高级概述开始
  - 包含具体、可操作的要求
  - 展示正确实现的示例
  - 尽可能引用现有代码
  - 通过引用其他规则保持规则的 DRY 原则

- **规则维护：**
  - 当出现新的模式时更新规则
  - 添加实际代码库中的示例
  - 移除过时的模式
  - 交叉引用相关规则

- **最佳实践：**
  - 使用项目符号以清晰表达
  - 保持描述简洁
  - 同时包含 DO 和 DON'T 示例
  - 引用实际代码而非理论示例
  - 在规则中保持一致的格式

---
自我改进（SELF_IMPROVE）
---
说明：根据出现的代码模式和最佳实践持续改进此规则文件的指南。
适用模式：**/*
适用文件：**/*
始终应用：是
---

- **规则改进触发因素：**
  - 出现未被现有规则涵盖的新代码模式
  - 文件中反复出现类似的实现
  - 可预防的常见错误模式
  - 持续使用的新库或工具
  - 代码库中出现的新最佳实践

- **分析流程：**
  - 将新代码与现有规则进行比较
  - 识别应标准化的模式
  - 查找对外部文档的引用
  - 检查一致的错误处理模式
  - 监控测试模式和覆盖范围

- **规则更新：**
  - **添加新规则的情况：**
    - 在 3 个或更多文件中使用了新的技术/模式
    - 规则可预防常见错误
    - 代码审查反复提及相同的反馈
    - 出现新的安全或性能模式

  - **修改现有规则的情况：**
    - 代码库中存在更好的示例
    - 发现额外的边缘情况
    - 相关规则已更新
    - 实现细节已更改

- **示例模式识别：**
  ```typescript
  // 如果您看到重复的模式，例如：
  const data = await prisma.user.findMany({
    select: { id: true, email: true },
    where: { status: 'ACTIVE' }
  });
  
  // 考虑在 .windsurfrules 中添加一个 PRISMA 部分：
  // - 标准选择字段
  // - 常见的 where 条件
  // - 性能优化模式
  ```

- **规则质量检查：**
  - 规则应具有可操作性和具体性
  - 示例应来自实际代码
  - 引用应保持最新
  - 模式应得到一致的执行

- **持续改进：**
  - 监控代码审查评论
  - 跟踪常见的开发问题
  - 在重大重构后更新规则
  - 添加相关文档的链接
  - 交叉引用相关规则

- **规则弃用：**
  - 标记过时的模式为弃用
  - 移除不再适用的规则
  - 更新对弃用规则的引用
  - 为旧模式记录迁移路径

- **文档更新：**
  - 保持示例与代码同步
  - 更新对外部文档的引用
  - 维护相关规则之间的链接
  - 记录破坏性变更

遵循 WINDSURF 规则进行适当的规则格式化和 WINDSURF 规则章节的结构。

# Added by Task Master - Development Workflow Rules

Below you will find a variety of important rules spanning:
- the dev_workflow
- the .windsurfrules document self-improvement workflow
- the template to follow when modifying or adding new sections/rules to this document.

---
DEV_WORKFLOW
---
description: Guide for using meta-development script (scripts/dev.js) to manage task-driven development workflows
globs: **/*
filesToApplyRule: **/*
alwaysApply: true
---

- **Global CLI Commands**
  - Task Master now provides a global CLI through the `task-master` command
  - All functionality from `scripts/dev.js` is available through this interface
  - Install globally with `npm install -g claude-task-master` or use locally via `npx`
  - Use `task-master <command>` instead of `node scripts/dev.js <command>`
  - Examples:
    - `task-master list` instead of `node scripts/dev.js list`
    - `task-master next` instead of `node scripts/dev.js next`
    - `task-master expand --id=3` instead of `node scripts/dev.js expand --id=3`
  - All commands accept the same options as their script equivalents
  - The CLI provides additional commands like `task-master init` for project setup

- **Development Workflow Process**
  - Start new projects by running `task-master init` or `node scripts/dev.js parse-prd --input=<prd-file.txt>` to generate initial tasks.json
  - Begin coding sessions with `task-master list` to see current tasks, status, and IDs
  - Analyze task complexity with `task-master analyze-complexity --research` before breaking down tasks
  - Select tasks based on dependencies (all marked 'done'), priority level, and ID order
  - Clarify tasks by checking task files in tasks/ directory or asking for user input
  - View specific task details using `task-master show <id>` to understand implementation requirements
  - Break down complex tasks using `task-master expand --id=<id>` with appropriate flags
  - Clear existing subtasks if needed using `task-master clear-subtasks --id=<id>` before regenerating
  - Implement code following task details, dependencies, and project standards
  - Verify tasks according to test strategies before marking as complete
  - Mark completed tasks with `task-master set-status --id=<id> --status=done`
  - Update dependent tasks when implementation differs from original plan
  - Generate task files with `task-master generate` after updating tasks.json
  - Maintain valid dependency structure with `task-master fix-dependencies` when needed
  - Respect dependency chains and task priorities when selecting work
  - Report progress regularly using the list command

- **Task Complexity Analysis**
  - Run `node scripts/dev.js analyze-complexity --research` for comprehensive analysis
  - Review complexity report in scripts/task-complexity-report.json
  - Or use `node scripts/dev.js complexity-report` for a formatted, readable version of the report
  - Focus on tasks with highest complexity scores (8-10) for detailed breakdown
  - Use analysis results to determine appropriate subtask allocation
  - Note that reports are automatically used by the expand command

- **Task Breakdown Process**
  - For tasks with complexity analysis, use `node scripts/dev.js expand --id=<id>`
  - Otherwise use `node scripts/dev.js expand --id=<id> --subtasks=<number>`
  - Add `--research` flag to leverage Perplexity AI for research-backed expansion
  - Use `--prompt="<context>"` to provide additional context when needed
  - Review and adjust generated subtasks as necessary
  - Use `--all` flag to expand multiple pending tasks at once
  - If subtasks need regeneration, clear them first with `clear-subtasks` command

- **Implementation Drift Handling**
  - When implementation differs significantly from planned approach
  - When future tasks need modification due to current implementation choices
  - When new dependencies or requirements emerge
  - Call `node scripts/dev.js update --from=<futureTaskId> --prompt="<explanation>"` to update tasks.json

- **Task Status Management**
  - Use 'pending' for tasks ready to be worked on
  - Use 'done' for completed and verified tasks
  - Use 'deferred' for postponed tasks
  - Add custom status values as needed for project-specific workflows

- **Task File Format Reference**
  ```
  # Task ID: <id>
  # Title: <title>
  # Status: <status>
  # Dependencies: <comma-separated list of dependency IDs>
  # Priority: <priority>
  # Description: <brief description>
  # Details:
  <detailed implementation notes>
  
  # Test Strategy:
  <verification approach>
  ```

- **Command Reference: parse-prd**
  - Legacy Syntax: `node scripts/dev.js parse-prd --input=<prd-file.txt>`
  - CLI Syntax: `task-master parse-prd --input=<prd-file.txt>`
  - Description: Parses a PRD document and generates a tasks.json file with structured tasks
  - Parameters: 
    - `--input=<file>`: Path to the PRD text file (default: sample-prd.txt)
  - Example: `task-master parse-prd --input=requirements.txt`
  - Notes: Will overwrite existing tasks.json file. Use with caution.

- **Command Reference: update**
  - Legacy Syntax: `node scripts/dev.js update --from=<id> --prompt="<prompt>"`
  - CLI Syntax: `task-master update --from=<id> --prompt="<prompt>"`
  - Description: Updates tasks with ID >= specified ID based on the provided prompt
  - Parameters:
    - `--from=<id>`: Task ID from which to start updating (required)
    - `--prompt="<text>"`: Explanation of changes or new context (required)
  - Example: `task-master update --from=4 --prompt="Now we are using Express instead of Fastify."`
  - Notes: Only updates tasks not marked as 'done'. Completed tasks remain unchanged.

- **Command Reference: generate**
  - Legacy Syntax: `node scripts/dev.js generate`
  - CLI Syntax: `task-master generate`
  - Description: Generates individual task files in tasks/ directory based on tasks.json
  - Parameters: 
    - `--file=<path>, -f`: Use alternative tasks.json file (default: 'tasks/tasks.json')
    - `--output=<dir>, -o`: Output directory (default: 'tasks')
  - Example: `task-master generate`
  - Notes: Overwrites existing task files. Creates tasks/ directory if needed.

- **Command Reference: set-status**
  - Legacy Syntax: `node scripts/dev.js set-status --id=<id> --status=<status>`
  - CLI Syntax: `task-master set-status --id=<id> --status=<status>`
  - Description: Updates the status of a specific task in tasks.json
  - Parameters:
    - `--id=<id>`: ID of the task to update (required)
    - `--status=<status>`: New status value (required)
  - Example: `task-master set-status --id=3 --status=done`
  - Notes: Common values are 'done', 'pending', and 'deferred', but any string is accepted.

- **Command Reference: list**
  - Legacy Syntax: `node scripts/dev.js list`
  - CLI Syntax: `task-master list`
  - Description: Lists all tasks in tasks.json with IDs, titles, and status
  - Parameters: 
    - `--status=<status>, -s`: Filter by status
    - `--with-subtasks`: Show subtasks for each task
    - `--file=<path>, -f`: Use alternative tasks.json file (default: 'tasks/tasks.json')
  - Example: `task-master list`
  - Notes: Provides quick overview of project progress. Use at start of sessions.

- **Command Reference: expand**
  - Legacy Syntax: `node scripts/dev.js expand --id=<id> [--num=<number>] [--research] [--prompt="<context>"]`
  - CLI Syntax: `task-master expand --id=<id> [--num=<number>] [--research] [--prompt="<context>"]`
  - Description: Expands a task with subtasks for detailed implementation
  - Parameters:
    - `--id=<id>`: ID of task to expand (required unless using --all)
    - `--all`: Expand all pending tasks, prioritized by complexity
    - `--num=<number>`: Number of subtasks to generate (default: from complexity report)
    - `--research`: Use Perplexity AI for research-backed generation
    - `--prompt="<text>"`: Additional context for subtask generation
    - `--force`: Regenerate subtasks even for tasks that already have them
  - Example: `task-master expand --id=3 --num=5 --research --prompt="Focus on security aspects"`
  - Notes: Uses complexity report recommendations if available.

- **Command Reference: analyze-complexity**
  - Legacy Syntax: `node scripts/dev.js analyze-complexity [options]`
  - CLI Syntax: `task-master analyze-complexity [options]`
  - Description: Analyzes task complexity and generates expansion recommendations
  - Parameters:
    - `--output=<file>, -o`: Output file path (default: scripts/task-complexity-report.json)
    - `--model=<model>, -m`: Override LLM model to use
    - `--threshold=<number>, -t`: Minimum score for expansion recommendation (default: 5)
    - `--file=<path>, -f`: Use alternative tasks.json file
    - `--research, -r`: Use Perplexity AI for research-backed analysis
  - Example: `task-master analyze-complexity --research`
  - Notes: Report includes complexity scores, recommended subtasks, and tailored prompts.

- **Command Reference: clear-subtasks**
  - Legacy Syntax: `node scripts/dev.js clear-subtasks --id=<id>`
  - CLI Syntax: `task-master clear-subtasks --id=<id>`
  - Description: Removes subtasks from specified tasks to allow regeneration
  - Parameters:
    - `--id=<id>`: ID or comma-separated IDs of tasks to clear subtasks from
    - `--all`: Clear subtasks from all tasks
  - Examples:
    - `task-master clear-subtasks --id=3`
    - `task-master clear-subtasks --id=1,2,3`
    - `task-master clear-subtasks --all`
  - Notes: 
    - Task files are automatically regenerated after clearing subtasks
    - Can be combined with expand command to immediately generate new subtasks
    - Works with both parent tasks and individual subtasks

- **Task Structure Fields**
  - **id**: Unique identifier for the task (Example: `1`)
  - **title**: Brief, descriptive title (Example: `"Initialize Repo"`)
  - **description**: Concise summary of what the task involves (Example: `"Create a new repository, set up initial structure."`)
  - **status**: Current state of the task (Example: `"pending"`, `"done"`, `"deferred"`)
  - **dependencies**: IDs of prerequisite tasks (Example: `[1, 2]`)
    - Dependencies are displayed with status indicators (✅ for completed, ⏱️ for pending)
    - This helps quickly identify which prerequisite tasks are blocking work
  - **priority**: Importance level (Example: `"high"`, `"medium"`, `"low"`)
  - **details**: In-depth implementation instructions (Example: `"Use GitHub client ID/secret, handle callback, set session token."`)
  - **testStrategy**: Verification approach (Example: `"Deploy and call endpoint to confirm 'Hello World' response."`)
  - **subtasks**: List of smaller, more specific tasks (Example: `[{"id": 1, "title": "Configure OAuth", ...}]`)

- **Environment Variables Configuration**
  - **ANTHROPIC_API_KEY** (Required): Your Anthropic API key for Claude (Example: `ANTHROPIC_API_KEY=sk-ant-api03-...`)
  - **MODEL** (Default: `"claude-3-7-sonnet-20250219"`): Claude model to use (Example: `MODEL=claude-3-opus-20240229`)
  - **MAX_TOKENS** (Default: `"4000"`): Maximum tokens for responses (Example: `MAX_TOKENS=8000`)
  - **TEMPERATURE** (Default: `"0.7"`): Temperature for model responses (Example: `TEMPERATURE=0.5`)
  - **DEBUG** (Default: `"false"`): Enable debug logging (Example: `DEBUG=true`)
  - **TASKMASTER_LOG_LEVEL** (Default: `"info"`): Console output level (Example: `TASKMASTER_LOG_LEVEL=debug`)
  - **DEFAULT_SUBTASKS** (Default: `"3"`): Default subtask count (Example: `DEFAULT_SUBTASKS=5`)
  - **DEFAULT_PRIORITY** (Default: `"medium"`): Default priority (Example: `DEFAULT_PRIORITY=high`)
  - **PROJECT_NAME** (Default: `"MCP SaaS MVP"`): Project name in metadata (Example: `PROJECT_NAME=My Awesome Project`)
  - **PROJECT_VERSION** (Default: `"1.0.0"`): Version in metadata (Example: `PROJECT_VERSION=2.1.0`)
  - **PERPLEXITY_API_KEY**: For research-backed features (Example: `PERPLEXITY_API_KEY=pplx-...`)
  - **PERPLEXITY_MODEL** (Default: `"sonar-medium-online"`): Perplexity model (Example: `PERPLEXITY_MODEL=sonar-large-online`)

- **Determining the Next Task**
  - Run `task-master next` to show the next task to work on
  - The next command identifies tasks with all dependencies satisfied
  - Tasks are prioritized by priority level, dependency count, and ID
  - The command shows comprehensive task information including:
    - Basic task details and description
    - Implementation details
    - Subtasks (if they exist)
    - Contextual suggested actions
  - Recommended before starting any new development work
  - Respects your project's dependency structure
  - Ensures tasks are completed in the appropriate sequence
  - Provides ready-to-use commands for common task actions

- **Viewing Specific Task Details**
  - Run `task-master show <id>` or `task-master show --id=<id>` to view a specific task
  - Use dot notation for subtasks: `task-master show 1.2` (shows subtask 2 of task 1)
  - Displays comprehensive information similar to the next command, but for a specific task
  - For parent tasks, shows all subtasks and their current status
  - For subtasks, shows parent task information and relationship
  - Provides contextual suggested actions appropriate for the specific task
  - Useful for examining task details before implementation or checking status

- **Managing Task Dependencies**
  - Use `task-master add-dependency --id=<id> --depends-on=<id>` to add a dependency
  - Use `task-master remove-dependency --id=<id> --depends-on=<id>` to remove a dependency
  - The system prevents circular dependencies and duplicate dependency entries
  - Dependencies are checked for existence before being added or removed
  - Task files are automatically regenerated after dependency changes
  - Dependencies are visualized with status indicators in task listings and files

- **Command Reference: add-dependency**
  - Legacy Syntax: `node scripts/dev.js add-dependency --id=<id> --depends-on=<id>`
  - CLI Syntax: `task-master add-dependency --id=<id> --depends-on=<id>`
  - Description: Adds a dependency relationship between two tasks
  - Parameters:
    - `--id=<id>`: ID of task that will depend on another task (required)
    - `--depends-on=<id>`: ID of task that will become a dependency (required)
  - Example: `task-master add-dependency --id=22 --depends-on=21`
  - Notes: Prevents circular dependencies and duplicates; updates task files automatically

- **Command Reference: remove-dependency**
  - Legacy Syntax: `node scripts/dev.js remove-dependency --id=<id> --depends-on=<id>`
  - CLI Syntax: `task-master remove-dependency --id=<id> --depends-on=<id>`
  - Description: Removes a dependency relationship between two tasks
  - Parameters:
    - `--id=<id>`: ID of task to remove dependency from (required)
    - `--depends-on=<id>`: ID of task to remove as a dependency (required)
  - Example: `task-master remove-dependency --id=22 --depends-on=21`
  - Notes: Checks if dependency actually exists; updates task files automatically

- **Command Reference: validate-dependencies**
  - Legacy Syntax: `node scripts/dev.js validate-dependencies [options]`
  - CLI Syntax: `task-master validate-dependencies [options]`
  - Description: Checks for and identifies invalid dependencies in tasks.json and task files
  - Parameters:
    - `--file=<path>, -f`: Use alternative tasks.json file (default: 'tasks/tasks.json')
  - Example: `task-master validate-dependencies`
  - Notes: 
    - Reports all non-existent dependencies and self-dependencies without modifying files
    - Provides detailed statistics on task dependency state
    - Use before fix-dependencies to audit your task structure

- **Command Reference: fix-dependencies**
  - Legacy Syntax: `node scripts/dev.js fix-dependencies [options]`
  - CLI Syntax: `task-master fix-dependencies [options]`
  - Description: Finds and fixes all invalid dependencies in tasks.json and task files
  - Parameters:
    - `--file=<path>, -f`: Use alternative tasks.json file (default: 'tasks/tasks.json')
  - Example: `task-master fix-dependencies`
  - Notes: 
    - Removes references to non-existent tasks and subtasks
    - Eliminates self-dependencies (tasks depending on themselves)
    - Regenerates task files with corrected dependencies
    - Provides detailed report of all fixes made

- **Command Reference: complexity-report**
  - Legacy Syntax: `node scripts/dev.js complexity-report [options]`
  - CLI Syntax: `task-master complexity-report [options]`
  - Description: Displays the task complexity analysis report in a formatted, easy-to-read way
  - Parameters:
    - `--file=<path>, -f`: Path to the complexity report file (default: 'scripts/task-complexity-report.json')
  - Example: `task-master complexity-report`
  - Notes: 
    - Shows tasks organized by complexity score with recommended actions
    - Provides complexity distribution statistics
    - Displays ready-to-use expansion commands for complex tasks
    - If no report exists, offers to generate one interactively

- **Command Reference: add-task**
  - CLI Syntax: `task-master add-task [options]`
  - Description: Add a new task to tasks.json using AI
  - Parameters:
    - `--file=<path>, -f`: Path to the tasks file (default: 'tasks/tasks.json')
    - `--prompt=<text>, -p`: Description of the task to add (required)
    - `--dependencies=<ids>, -d`: Comma-separated list of task IDs this task depends on
    - `--priority=<priority>`: Task priority (high, medium, low) (default: 'medium')
  - Example: `task-master add-task --prompt="Create user authentication using Auth0"`
  - Notes: Uses AI to convert description into structured task with appropriate details

- **Command Reference: init**
  - CLI Syntax: `task-master init`
  - Description: Initialize a new project with Task Master structure
  - Parameters: None
  - Example: `task-master init`
  - Notes: 
    - Creates initial project structure with required files
    - Prompts for project settings if not provided
    - Merges with existing files when appropriate
    - Can be used to bootstrap a new Task Master project quickly

- **Code Analysis & Refactoring Techniques**
  - **Top-Level Function Search**
    - Use grep pattern matching to find all exported functions across the codebase
    - Command: `grep -E "export (function|const) \w+|function \w+\(|const \w+ = \(|module\.exports" --include="*.js" -r ./`
    - Benefits:
      - Quickly identify all public API functions without reading implementation details
      - Compare functions between files during refactoring (e.g., monolithic to modular structure)
      - Verify all expected functions exist in refactored modules
      - Identify duplicate functionality or naming conflicts
    - Usage examples:
      - When migrating from `scripts/dev.js` to modular structure: `grep -E "function \w+\(" scripts/dev.js`
      - Check function exports in a directory: `grep -E "export (function|const)" scripts/modules/`
      - Find potential naming conflicts: `grep -E "function (get|set|create|update)\w+\(" -r ./`
    - Variations:
      - Add `-n` flag to include line numbers
      - Add `--include="*.ts"` to filter by file extension
      - Use with `| sort` to alphabetize results
    - Integration with refactoring workflow:
      - Start by mapping all functions in the source file
      - Create target module files based on function grouping
      - Verify all functions were properly migrated
      - Check for any unintentional duplications or omissions

---
WINDSURF_RULES
---
description: Guidelines for creating and maintaining Windsurf rules to ensure consistency and effectiveness.
globs: .windsurfrules
filesToApplyRule: .windsurfrules
alwaysApply: true
---
The below describes how you should be structuring new rule sections in this document.
- **Required Rule Structure:**
  ```markdown
  ---
  description: Clear, one-line description of what the rule enforces
  globs: path/to/files/*.ext, other/path/**/*
  alwaysApply: boolean
  ---

  - **Main Points in Bold**
    - Sub-points with details
    - Examples and explanations
  ```

- **Section References:**
  - Use `ALL_CAPS_SECTION` to reference files
  - Example: `WINDSURF_RULES`

- **Code Examples:**
  - Use language-specific code blocks
  ```typescript
  // ✅ DO: Show good examples
  const goodExample = true;
  
  // ❌ DON'T: Show anti-patterns
  const badExample = false;
  ```

- **Rule Content Guidelines:**
  - Start with high-level overview
  - Include specific, actionable requirements
  - Show examples of correct implementation
  - Reference existing code when possible
  - Keep rules DRY by referencing other rules

- **Rule Maintenance:**
  - Update rules when new patterns emerge
  - Add examples from actual codebase
  - Remove outdated patterns
  - Cross-reference related rules

- **Best Practices:**
  - Use bullet points for clarity
  - Keep descriptions concise
  - Include both DO and DON'T examples
  - Reference actual code over theoretical examples
  - Use consistent formatting across rules 

---
SELF_IMPROVE
---
description: Guidelines for continuously improving this rules document based on emerging code patterns and best practices.
globs: **/*
filesToApplyRule: **/*
alwaysApply: true
---

- **Rule Improvement Triggers:**
  - New code patterns not covered by existing rules
  - Repeated similar implementations across files
  - Common error patterns that could be prevented
  - New libraries or tools being used consistently
  - Emerging best practices in the codebase

- **Analysis Process:**
  - Compare new code with existing rules
  - Identify patterns that should be standardized
  - Look for references to external documentation
  - Check for consistent error handling patterns
  - Monitor test patterns and coverage

- **Rule Updates:**
  - **Add New Rules When:**
    - A new technology/pattern is used in 3+ files
    - Common bugs could be prevented by a rule
    - Code reviews repeatedly mention the same feedback
    - New security or performance patterns emerge

  - **Modify Existing Rules When:**
    - Better examples exist in the codebase
    - Additional edge cases are discovered
    - Related rules have been updated
    - Implementation details have changed

- **Example Pattern Recognition:**
  ```typescript
  // If you see repeated patterns like:
  const data = await prisma.user.findMany({
    select: { id: true, email: true },
    where: { status: 'ACTIVE' }
  });
  
  // Consider adding a PRISMA section in the .windsurfrules:
  // - Standard select fields
  // - Common where conditions
  // - Performance optimization patterns
  ```

- **Rule Quality Checks:**
  - Rules should be actionable and specific
  - Examples should come from actual code
  - References should be up to date
  - Patterns should be consistently enforced

- **Continuous Improvement:**
  - Monitor code review comments
  - Track common development questions
  - Update rules after major refactors
  - Add links to relevant documentation
  - Cross-reference related rules

- **Rule Deprecation:**
  - Mark outdated patterns as deprecated
  - Remove rules that no longer apply
  - Update references to deprecated rules
  - Document migration paths for old patterns

- **Documentation Updates:**
  - Keep examples synchronized with code
  - Update references to external docs
  - Maintain links between related rules
  - Document breaking changes

Follow WINDSURF_RULES for proper rule formatting and structure of windsurf rule sections.

# Added by Task Master - Development Workflow Rules

Below you will find a variety of important rules spanning:
- the dev_workflow
- the .windsurfrules document self-improvement workflow
- the template to follow when modifying or adding new sections/rules to this document.

---
DEV_WORKFLOW
---
description: Guide for using meta-development script (scripts/dev.js) to manage task-driven development workflows
globs: **/*
filesToApplyRule: **/*
alwaysApply: true
---

- **Global CLI Commands**
  - Task Master now provides a global CLI through the `task-master` command
  - All functionality from `scripts/dev.js` is available through this interface
  - Install globally with `npm install -g claude-task-master` or use locally via `npx`
  - Use `task-master <command>` instead of `node scripts/dev.js <command>`
  - Examples:
    - `task-master list` instead of `node scripts/dev.js list`
    - `task-master next` instead of `node scripts/dev.js next`
    - `task-master expand --id=3` instead of `node scripts/dev.js expand --id=3`
  - All commands accept the same options as their script equivalents
  - The CLI provides additional commands like `task-master init` for project setup

- **Development Workflow Process**
  - Start new projects by running `task-master init` or `node scripts/dev.js parse-prd --input=<prd-file.txt>` to generate initial tasks.json
  - Begin coding sessions with `task-master list` to see current tasks, status, and IDs
  - Analyze task complexity with `task-master analyze-complexity --research` before breaking down tasks
  - Select tasks based on dependencies (all marked 'done'), priority level, and ID order
  - Clarify tasks by checking task files in tasks/ directory or asking for user input
  - View specific task details using `task-master show <id>` to understand implementation requirements
  - Break down complex tasks using `task-master expand --id=<id>` with appropriate flags
  - Clear existing subtasks if needed using `task-master clear-subtasks --id=<id>` before regenerating
  - Implement code following task details, dependencies, and project standards
  - Verify tasks according to test strategies before marking as complete
  - Mark completed tasks with `task-master set-status --id=<id> --status=done`
  - Update dependent tasks when implementation differs from original plan
  - Generate task files with `task-master generate` after updating tasks.json
  - Maintain valid dependency structure with `task-master fix-dependencies` when needed
  - Respect dependency chains and task priorities when selecting work
  - Report progress regularly using the list command

- **Task Complexity Analysis**
  - Run `node scripts/dev.js analyze-complexity --research` for comprehensive analysis
  - Review complexity report in scripts/task-complexity-report.json
  - Or use `node scripts/dev.js complexity-report` for a formatted, readable version of the report
  - Focus on tasks with highest complexity scores (8-10) for detailed breakdown
  - Use analysis results to determine appropriate subtask allocation
  - Note that reports are automatically used by the expand command

- **Task Breakdown Process**
  - For tasks with complexity analysis, use `node scripts/dev.js expand --id=<id>`
  - Otherwise use `node scripts/dev.js expand --id=<id> --subtasks=<number>`
  - Add `--research` flag to leverage Perplexity AI for research-backed expansion
  - Use `--prompt="<context>"` to provide additional context when needed
  - Review and adjust generated subtasks as necessary
  - Use `--all` flag to expand multiple pending tasks at once
  - If subtasks need regeneration, clear them first with `clear-subtasks` command

- **Implementation Drift Handling**
  - When implementation differs significantly from planned approach
  - When future tasks need modification due to current implementation choices
  - When new dependencies or requirements emerge
  - Call `node scripts/dev.js update --from=<futureTaskId> --prompt="<explanation>"` to update tasks.json

- **Task Status Management**
  - Use 'pending' for tasks ready to be worked on
  - Use 'done' for completed and verified tasks
  - Use 'deferred' for postponed tasks
  - Add custom status values as needed for project-specific workflows

- **Task File Format Reference**
  ```
  # Task ID: <id>
  # Title: <title>
  # Status: <status>
  # Dependencies: <comma-separated list of dependency IDs>
  # Priority: <priority>
  # Description: <brief description>
  # Details:
  <detailed implementation notes>
  
  # Test Strategy:
  <verification approach>
  ```

- **Command Reference: parse-prd**
  - Legacy Syntax: `node scripts/dev.js parse-prd --input=<prd-file.txt>`
  - CLI Syntax: `task-master parse-prd --input=<prd-file.txt>`
  - Description: Parses a PRD document and generates a tasks.json file with structured tasks
  - Parameters: 
    - `--input=<file>`: Path to the PRD text file (default: sample-prd.txt)
  - Example: `task-master parse-prd --input=requirements.txt`
  - Notes: Will overwrite existing tasks.json file. Use with caution.

- **Command Reference: update**
  - Legacy Syntax: `node scripts/dev.js update --from=<id> --prompt="<prompt>"`
  - CLI Syntax: `task-master update --from=<id> --prompt="<prompt>"`
  - Description: Updates tasks with ID >= specified ID based on the provided prompt
  - Parameters:
    - `--from=<id>`: Task ID from which to start updating (required)
    - `--prompt="<text>"`: Explanation of changes or new context (required)
  - Example: `task-master update --from=4 --prompt="Now we are using Express instead of Fastify."`
  - Notes: Only updates tasks not marked as 'done'. Completed tasks remain unchanged.

- **Command Reference: generate**
  - Legacy Syntax: `node scripts/dev.js generate`
  - CLI Syntax: `task-master generate`
  - Description: Generates individual task files in tasks/ directory based on tasks.json
  - Parameters: 
    - `--file=<path>, -f`: Use alternative tasks.json file (default: 'tasks/tasks.json')
    - `--output=<dir>, -o`: Output directory (default: 'tasks')
  - Example: `task-master generate`
  - Notes: Overwrites existing task files. Creates tasks/ directory if needed.

- **Command Reference: set-status**
  - Legacy Syntax: `node scripts/dev.js set-status --id=<id> --status=<status>`
  - CLI Syntax: `task-master set-status --id=<id> --status=<status>`
  - Description: Updates the status of a specific task in tasks.json
  - Parameters:
    - `--id=<id>`: ID of the task to update (required)
    - `--status=<status>`: New status value (required)
  - Example: `task-master set-status --id=3 --status=done`
  - Notes: Common values are 'done', 'pending', and 'deferred', but any string is accepted.

- **Command Reference: list**
  - Legacy Syntax: `node scripts/dev.js list`
  - CLI Syntax: `task-master list`
  - Description: Lists all tasks in tasks.json with IDs, titles, and status
  - Parameters: 
    - `--status=<status>, -s`: Filter by status
    - `--with-subtasks`: Show subtasks for each task
    - `--file=<path>, -f`: Use alternative tasks.json file (default: 'tasks/tasks.json')
  - Example: `task-master list`
  - Notes: Provides quick overview of project progress. Use at start of sessions.

- **Command Reference: expand**
  - Legacy Syntax: `node scripts/dev.js expand --id=<id> [--num=<number>] [--research] [--prompt="<context>"]`
  - CLI Syntax: `task-master expand --id=<id> [--num=<number>] [--research] [--prompt="<context>"]`
  - Description: Expands a task with subtasks for detailed implementation
  - Parameters:
    - `--id=<id>`: ID of task to expand (required unless using --all)
    - `--all`: Expand all pending tasks, prioritized by complexity
    - `--num=<number>`: Number of subtasks to generate (default: from complexity report)
    - `--research`: Use Perplexity AI for research-backed generation
    - `--prompt="<text>"`: Additional context for subtask generation
    - `--force`: Regenerate subtasks even for tasks that already have them
  - Example: `task-master expand --id=3 --num=5 --research --prompt="Focus on security aspects"`
  - Notes: Uses complexity report recommendations if available.

- **Command Reference: analyze-complexity**
  - Legacy Syntax: `node scripts/dev.js analyze-complexity [options]`
  - CLI Syntax: `task-master analyze-complexity [options]`
  - Description: Analyzes task complexity and generates expansion recommendations
  - Parameters:
    - `--output=<file>, -o`: Output file path (default: scripts/task-complexity-report.json)
    - `--model=<model>, -m`: Override LLM model to use
    - `--threshold=<number>, -t`: Minimum score for expansion recommendation (default: 5)
    - `--file=<path>, -f`: Use alternative tasks.json file
    - `--research, -r`: Use Perplexity AI for research-backed analysis
  - Example: `task-master analyze-complexity --research`
  - Notes: Report includes complexity scores, recommended subtasks, and tailored prompts.

- **Command Reference: clear-subtasks**
  - Legacy Syntax: `node scripts/dev.js clear-subtasks --id=<id>`
  - CLI Syntax: `task-master clear-subtasks --id=<id>`
  - Description: Removes subtasks from specified tasks to allow regeneration
  - Parameters:
    - `--id=<id>`: ID or comma-separated IDs of tasks to clear subtasks from
    - `--all`: Clear subtasks from all tasks
  - Examples:
    - `task-master clear-subtasks --id=3`
    - `task-master clear-subtasks --id=1,2,3`
    - `task-master clear-subtasks --all`
  - Notes: 
    - Task files are automatically regenerated after clearing subtasks
    - Can be combined with expand command to immediately generate new subtasks
    - Works with both parent tasks and individual subtasks

- **Task Structure Fields**
  - **id**: Unique identifier for the task (Example: `1`)
  - **title**: Brief, descriptive title (Example: `"Initialize Repo"`)
  - **description**: Concise summary of what the task involves (Example: `"Create a new repository, set up initial structure."`)
  - **status**: Current state of the task (Example: `"pending"`, `"done"`, `"deferred"`)
  - **dependencies**: IDs of prerequisite tasks (Example: `[1, 2]`)
    - Dependencies are displayed with status indicators (✅ for completed, ⏱️ for pending)
    - This helps quickly identify which prerequisite tasks are blocking work
  - **priority**: Importance level (Example: `"high"`, `"medium"`, `"low"`)
  - **details**: In-depth implementation instructions (Example: `"Use GitHub client ID/secret, handle callback, set session token."`)
  - **testStrategy**: Verification approach (Example: `"Deploy and call endpoint to confirm 'Hello World' response."`)
  - **subtasks**: List of smaller, more specific tasks (Example: `[{"id": 1, "title": "Configure OAuth", ...}]`)

- **Environment Variables Configuration**
  - **ANTHROPIC_API_KEY** (Required): Your Anthropic API key for Claude (Example: `ANTHROPIC_API_KEY=sk-ant-api03-...`)
  - **MODEL** (Default: `"claude-3-7-sonnet-20250219"`): Claude model to use (Example: `MODEL=claude-3-opus-20240229`)
  - **MAX_TOKENS** (Default: `"4000"`): Maximum tokens for responses (Example: `MAX_TOKENS=8000`)
  - **TEMPERATURE** (Default: `"0.7"`): Temperature for model responses (Example: `TEMPERATURE=0.5`)
  - **DEBUG** (Default: `"false"`): Enable debug logging (Example: `DEBUG=true`)
  - **TASKMASTER_LOG_LEVEL** (Default: `"info"`): Console output level (Example: `TASKMASTER_LOG_LEVEL=debug`)
  - **DEFAULT_SUBTASKS** (Default: `"3"`): Default subtask count (Example: `DEFAULT_SUBTASKS=5`)
  - **DEFAULT_PRIORITY** (Default: `"medium"`): Default priority (Example: `DEFAULT_PRIORITY=high`)
  - **PROJECT_NAME** (Default: `"MCP SaaS MVP"`): Project name in metadata (Example: `PROJECT_NAME=My Awesome Project`)
  - **PROJECT_VERSION** (Default: `"1.0.0"`): Version in metadata (Example: `PROJECT_VERSION=2.1.0`)
  - **PERPLEXITY_API_KEY**: For research-backed features (Example: `PERPLEXITY_API_KEY=pplx-...`)
  - **PERPLEXITY_MODEL** (Default: `"sonar-medium-online"`): Perplexity model (Example: `PERPLEXITY_MODEL=sonar-large-online`)

- **Determining the Next Task**
  - Run `task-master next` to show the next task to work on
  - The next command identifies tasks with all dependencies satisfied
  - Tasks are prioritized by priority level, dependency count, and ID
  - The command shows comprehensive task information including:
    - Basic task details and description
    - Implementation details
    - Subtasks (if they exist)
    - Contextual suggested actions
  - Recommended before starting any new development work
  - Respects your project's dependency structure
  - Ensures tasks are completed in the appropriate sequence
  - Provides ready-to-use commands for common task actions

- **Viewing Specific Task Details**
  - Run `task-master show <id>` or `task-master show --id=<id>` to view a specific task
  - Use dot notation for subtasks: `task-master show 1.2` (shows subtask 2 of task 1)
  - Displays comprehensive information similar to the next command, but for a specific task
  - For parent tasks, shows all subtasks and their current status
  - For subtasks, shows parent task information and relationship
  - Provides contextual suggested actions appropriate for the specific task
  - Useful for examining task details before implementation or checking status

- **Managing Task Dependencies**
  - Use `task-master add-dependency --id=<id> --depends-on=<id>` to add a dependency
  - Use `task-master remove-dependency --id=<id> --depends-on=<id>` to remove a dependency
  - The system prevents circular dependencies and duplicate dependency entries
  - Dependencies are checked for existence before being added or removed
  - Task files are automatically regenerated after dependency changes
  - Dependencies are visualized with status indicators in task listings and files

- **Command Reference: add-dependency**
  - Legacy Syntax: `node scripts/dev.js add-dependency --id=<id> --depends-on=<id>`
  - CLI Syntax: `task-master add-dependency --id=<id> --depends-on=<id>`
  - Description: Adds a dependency relationship between two tasks
  - Parameters:
    - `--id=<id>`: ID of task that will depend on another task (required)
    - `--depends-on=<id>`: ID of task that will become a dependency (required)
  - Example: `task-master add-dependency --id=22 --depends-on=21`
  - Notes: Prevents circular dependencies and duplicates; updates task files automatically

- **Command Reference: remove-dependency**
  - Legacy Syntax: `node scripts/dev.js remove-dependency --id=<id> --depends-on=<id>`
  - CLI Syntax: `task-master remove-dependency --id=<id> --depends-on=<id>`
  - Description: Removes a dependency relationship between two tasks
  - Parameters:
    - `--id=<id>`: ID of task to remove dependency from (required)
    - `--depends-on=<id>`: ID of task to remove as a dependency (required)
  - Example: `task-master remove-dependency --id=22 --depends-on=21`
  - Notes: Checks if dependency actually exists; updates task files automatically

- **Command Reference: validate-dependencies**
  - Legacy Syntax: `node scripts/dev.js validate-dependencies [options]`
  - CLI Syntax: `task-master validate-dependencies [options]`
  - Description: Checks for and identifies invalid dependencies in tasks.json and task files
  - Parameters:
    - `--file=<path>, -f`: Use alternative tasks.json file (default: 'tasks/tasks.json')
  - Example: `task-master validate-dependencies`
  - Notes: 
    - Reports all non-existent dependencies and self-dependencies without modifying files
    - Provides detailed statistics on task dependency state
    - Use before fix-dependencies to audit your task structure

- **Command Reference: fix-dependencies**
  - Legacy Syntax: `node scripts/dev.js fix-dependencies [options]`
  - CLI Syntax: `task-master fix-dependencies [options]`
  - Description: Finds and fixes all invalid dependencies in tasks.json and task files
  - Parameters:
    - `--file=<path>, -f`: Use alternative tasks.json file (default: 'tasks/tasks.json')
  - Example: `task-master fix-dependencies`
  - Notes: 
    - Removes references to non-existent tasks and subtasks
    - Eliminates self-dependencies (tasks depending on themselves)
    - Regenerates task files with corrected dependencies
    - Provides detailed report of all fixes made

- **Command Reference: complexity-report**
  - Legacy Syntax: `node scripts/dev.js complexity-report [options]`
  - CLI Syntax: `task-master complexity-report [options]`
  - Description: Displays the task complexity analysis report in a formatted, easy-to-read way
  - Parameters:
    - `--file=<path>, -f`: Path to the complexity report file (default: 'scripts/task-complexity-report.json')
  - Example: `task-master complexity-report`
  - Notes: 
    - Shows tasks organized by complexity score with recommended actions
    - Provides complexity distribution statistics
    - Displays ready-to-use expansion commands for complex tasks
    - If no report exists, offers to generate one interactively

- **Command Reference: add-task**
  - CLI Syntax: `task-master add-task [options]`
  - Description: Add a new task to tasks.json using AI
  - Parameters:
    - `--file=<path>, -f`: Path to the tasks file (default: 'tasks/tasks.json')
    - `--prompt=<text>, -p`: Description of the task to add (required)
    - `--dependencies=<ids>, -d`: Comma-separated list of task IDs this task depends on
    - `--priority=<priority>`: Task priority (high, medium, low) (default: 'medium')
  - Example: `task-master add-task --prompt="Create user authentication using Auth0"`
  - Notes: Uses AI to convert description into structured task with appropriate details

- **Command Reference: init**
  - CLI Syntax: `task-master init`
  - Description: Initialize a new project with Task Master structure
  - Parameters: None
  - Example: `task-master init`
  - Notes: 
    - Creates initial project structure with required files
    - Prompts for project settings if not provided
    - Merges with existing files when appropriate
    - Can be used to bootstrap a new Task Master project quickly

- **Code Analysis & Refactoring Techniques**
  - **Top-Level Function Search**
    - Use grep pattern matching to find all exported functions across the codebase
    - Command: `grep -E "export (function|const) \w+|function \w+\(|const \w+ = \(|module\.exports" --include="*.js" -r ./`
    - Benefits:
      - Quickly identify all public API functions without reading implementation details
      - Compare functions between files during refactoring (e.g., monolithic to modular structure)
      - Verify all expected functions exist in refactored modules
      - Identify duplicate functionality or naming conflicts
    - Usage examples:
      - When migrating from `scripts/dev.js` to modular structure: `grep -E "function \w+\(" scripts/dev.js`
      - Check function exports in a directory: `grep -E "export (function|const)" scripts/modules/`
      - Find potential naming conflicts: `grep -E "function (get|set|create|update)\w+\(" -r ./`
    - Variations:
      - Add `-n` flag to include line numbers
      - Add `--include="*.ts"` to filter by file extension
      - Use with `| sort` to alphabetize results
    - Integration with refactoring workflow:
      - Start by mapping all functions in the source file
      - Create target module files based on function grouping
      - Verify all functions were properly migrated
      - Check for any unintentional duplications or omissions

---
WINDSURF_RULES
---
description: Guidelines for creating and maintaining Windsurf rules to ensure consistency and effectiveness.
globs: .windsurfrules
filesToApplyRule: .windsurfrules
alwaysApply: true
---
The below describes how you should be structuring new rule sections in this document.
- **Required Rule Structure:**
  ```markdown
  ---
  description: Clear, one-line description of what the rule enforces
  globs: path/to/files/*.ext, other/path/**/*
  alwaysApply: boolean
  ---

  - **Main Points in Bold**
    - Sub-points with details
    - Examples and explanations
  ```

- **Section References:**
  - Use `ALL_CAPS_SECTION` to reference files
  - Example: `WINDSURF_RULES`

- **Code Examples:**
  - Use language-specific code blocks
  ```typescript
  // ✅ DO: Show good examples
  const goodExample = true;
  
  // ❌ DON'T: Show anti-patterns
  const badExample = false;
  ```

- **Rule Content Guidelines:**
  - Start with high-level overview
  - Include specific, actionable requirements
  - Show examples of correct implementation
  - Reference existing code when possible
  - Keep rules DRY by referencing other rules

- **Rule Maintenance:**
  - Update rules when new patterns emerge
  - Add examples from actual codebase
  - Remove outdated patterns
  - Cross-reference related rules

- **Best Practices:**
  - Use bullet points for clarity
  - Keep descriptions concise
  - Include both DO and DON'T examples
  - Reference actual code over theoretical examples
  - Use consistent formatting across rules 

---
SELF_IMPROVE
---
description: Guidelines for continuously improving this rules document based on emerging code patterns and best practices.
globs: **/*
filesToApplyRule: **/*
alwaysApply: true
---

- **Rule Improvement Triggers:**
  - New code patterns not covered by existing rules
  - Repeated similar implementations across files
  - Common error patterns that could be prevented
  - New libraries or tools being used consistently
  - Emerging best practices in the codebase

- **Analysis Process:**
  - Compare new code with existing rules
  - Identify patterns that should be standardized
  - Look for references to external documentation
  - Check for consistent error handling patterns
  - Monitor test patterns and coverage

- **Rule Updates:**
  - **Add New Rules When:**
    - A new technology/pattern is used in 3+ files
    - Common bugs could be prevented by a rule
    - Code reviews repeatedly mention the same feedback
    - New security or performance patterns emerge

  - **Modify Existing Rules When:**
    - Better examples exist in the codebase
    - Additional edge cases are discovered
    - Related rules have been updated
    - Implementation details have changed

- **Example Pattern Recognition:**
  ```typescript
  // If you see repeated patterns like:
  const data = await prisma.user.findMany({
    select: { id: true, email: true },
    where: { status: 'ACTIVE' }
  });
  
  // Consider adding a PRISMA section in the .windsurfrules:
  // - Standard select fields
  // - Common where conditions
  // - Performance optimization patterns
  ```

- **Rule Quality Checks:**
  - Rules should be actionable and specific
  - Examples should come from actual code
  - References should be up to date
  - Patterns should be consistently enforced

- **Continuous Improvement:**
  - Monitor code review comments
  - Track common development questions
  - Update rules after major refactors
  - Add links to relevant documentation
  - Cross-reference related rules

- **Rule Deprecation:**
  - Mark outdated patterns as deprecated
  - Remove rules that no longer apply
  - Update references to deprecated rules
  - Document migration paths for old patterns

- **Documentation Updates:**
  - Keep examples synchronized with code
  - Update references to external docs
  - Maintain links between related rules
  - Document breaking changes

Follow WINDSURF_RULES for proper rule formatting and structure of windsurf rule sections.